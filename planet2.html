<html>
  <head>
    <title>threejs planet</title>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport"/>
    <style type="text/css">
    body{
      margin:0;
    }
    canvas{
      width:100%;
      height:100%
    }
    </style>
  </head>
  <body ontouchmove="event.preventDefault();">
    <script src="js/three.min.js"></script>
    <script src="js/inflate.min.js"></script>
    <script src="js/FBXLoader.js"></script>
    <script src="js/framerate.js"></script>
    <script>
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      var renderer = new THREE.WebGLRenderer();
      var touchDown = false;

      renderer.setSize(window.innerWidth,window.innerHeight);
      //load the canvas
      document.body.appendChild(renderer.domElement);

      //set the resize event
      window.addEventListener('resize',function(){
        renderer.setSize(window.innerWidth,window.innerHeight);
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
      });

      camera.position.set(0,0,300);
      camera.lookAt(0,0,0);

      var ambientLight = new THREE.AmbientLight(0xffffff,0.2)
      scene.add(ambientLight);

      var directionLight1 = new THREE.DirectionalLight(0xffffff,0.8);
      directionLight1.position.set(300,0,400);
      directionLight1.castShadow = true;
      directionLight1.mapSize = new THREE.Vector2(1024,1024);
      var directionLight2 = new THREE.DirectionalLight(0x9999ff,0.2);
      directionLight2.position.set(-300,0,-400);
      directionLight2.castShadow = true;
      directionLight2.mapSize = new THREE.Vector2(1024,1024);
      scene.add(directionLight1)
      scene.add(directionLight2)

      //background-box
      var backgroundGeometry = new THREE.BoxGeometry(1000,1000,1000);
      var backgroundMaterial = new THREE.MeshBasicMaterial(
        {map:new THREE.TextureLoader().load("asset/textures/background-stars.jpg"),side:THREE.DoubleSide});
      var background = new THREE.Mesh(backgroundGeometry,backgroundMaterial);
      background.position.set(0,0,0)
      scene.add(background);

      //FBX Loader
      var mesh1;
      var fgxloader = new THREE.FBXLoader().
      load("asset/source/threejs_mars.fbx",function(object){
        object.position.set(0,0,0);
        object.receiveShadow = true;
        scene.add(object);
        mesh1 = object;
      },function(xhr){
        console.log("object "+(xhr.loaded/xhr.total*100)+"% loaded");
      },function(error){
        alert(error);
      });

      var mesh2;
      fgxloader = new THREE.FBXLoader().
      load("asset/source/threejs_marscloud.fbx",function(object){
        object.position.set(0,0,0);
        object.receiveShadow = true;
        //scene.add(object);
        mesh2 = object;
      },function(xhr){
        console.log("object "+(xhr.loaded/xhr.total*100)+"% loaded");
      },function(error){
        alert(error);
      });

      //update game parameters
      var lightRotateSpeed = 0.005,          //光源转速
          cloudRotateSpeed = -0.009,         //云层转速
          planetRotateSpeed = -0.007,        //行星转速
          resetRotateSpeed = 0.005;          //轨道恢复速度
          resetScaleSpeed = 0.005;           //大小恢复速度
      var lightRotateAngle = 0;
      var update = function(){
        if(!touchDown){
          //lightRotateAngle+=lightRotateSpeed;
          //directionLight1.position.x = 500*Math.cos(Math.PI/2+lightRotateAngle);
          //directionLight1.position.z = 500*Math.sin(Math.PI/2+lightRotateAngle);
          //directionLight2.position.x = 500*Math.cos(-Math.PI/2+lightRotateAngle);
          //directionLight2.position.z = 500*Math.sin(-Math.PI/2+lightRotateAngle);

          if(mesh1===undefined)
            return;
          //保持物体的自转是仅仅围绕Y轴。
          if(mesh1.rotation.x > 0){
            mesh1.rotation.x -= Math.abs(resetRotateSpeed);
            if(mesh1.rotation.x < 0)
              mesh1.rotation.x = 0;
              mesh1.rotation.y += planetRotateSpeed;
          }
          else if(mesh1.rotation.x < 0){
            mesh1.rotation.x += Math.abs(resetRotateSpeed);
            if(mesh1.rotation.x > 0)
              mesh1.rotation.x = 0;
              mesh1.rotation.y += planetRotateSpeed;
          }else{
            mesh1.rotation.y += planetRotateSpeed;
          }

          if(mesh1.scale.x > 1){
            mesh1.scale.x -= resetScaleSpeed;
            mesh1.scale.y -= resetScaleSpeed;
            mesh1.scale.z -= resetScaleSpeed;
            if(mesh1.scale.x <= 1){
              mesh1.scale.x = 1;
              mesh1.scale.y = 1;
              mesh1.scale.z = 1;
            }
          }
          else if (mesh1.scale.x < 1){
            mesh1.scale.x += resetScaleSpeed;
            mesh1.scale.y += resetScaleSpeed;
            mesh1.scale.z += resetScaleSpeed;
            if(mesh1.scale.x >= 1){
              mesh1.scale.x = 1;
              mesh1.scale.y = 1;
              mesh1.scale.z = 1;
            }
          }

          if(mesh2 === undefined)
            return;
          if(mesh2.rotation.x > 0){
            mesh2.rotation.x -= Math.abs(resetRotateSpeed);
            if(mesh2.rotation.x < 0)
              mesh2.rotation.x = 0;
              mesh2.rotation.y += cloudRotateSpeed;
          }
          else if(mesh2.rotation.x < 0){
            mesh2.rotation.x += Math.abs(resetRotateSpeed);
            if(mesh2.rotation.x > 0)
              mesh2.rotation.x = 0;
              mesh2.rotation.y += cloudRotateSpeed;
          }else{
            mesh2.rotation.y += cloudRotateSpeed;
          }
        }
      };

      //render the scene
      var render = function(){
        renderer.render(scene,camera);
      };

      var GameLoop = function(){
        requestAnimationFrame(GameLoop);
        update();
        render();
      }

      GameLoop();
    </script>
    <script>
      var touch1PositionX=0,                    //第一个触碰X坐标
          touch1PositionY=0,                    //第一个触碰Y坐标
          touch2PositionX=0,                    //第二个触碰X坐标
          touch2PositionY=0,                    //第二个触碰Y坐标
          touch1Distance=0;                     //两个触碰点间的距离
      var model1Rotation,model2Rotation;
      var model1Scale,model2Scale;
      var timeout;

      //旋转物体方法
      var rotateModels = function(model,startRotation,deltaAngleX,deltaAngleY,speed){
        //物体围绕x轴转动deltaAngleY/speed的角度
        model.rotation.x = startRotation.x + deltaAngleX/speed;
        //将物体的围绕X轴的转动角度限制在Math.PI/2和-Math.PI/2之间
        if(model.rotation.x >= Math.PI/2){
          model.rotation.x = Math.PI/2;
        }else if(model.rotation.x <= -Math.PI/2){
          model.rotation.x = -Math.PI/2;
        }
        //物体围绕y轴转动deltaAngleY/speed的角度
        model.rotation.y = startRotation.y + deltaAngleY/speed;
        //model1Rotation = model.rotation;
      };

      //缩放物体方法
      var scaleModels = function(model,deltaScale){
        model.scale.x = deltaScale;
        model.scale.y = deltaScale;
        model.scale.z = deltaScale;
        if(model.scale.x <= 1.0){
          model.scale.x = 1.0;
          model.scale.y = 1.0;
          model.scale.z = 1.0;
        }else if(model.scale.x >= 1.8){
          model.scale.x = 1.8;
          model.scale.y = 1.8;
          model.scale.z = 1.8;
        }
      }

      //触碰开始方法
      var touchstart = function(event){
        event.preventDefault();
        //如果结束触碰后5秒之内，再次触碰，则清空倒计时
        if(timeout>0)
          clearTimeout(timeout);
        touchDown = true;    //开始触碰
        var targetTouches = event.targetTouches;
        //排除无接触与三只手指以上接触的。
        if(targetTouches === null|| targetTouches.length<=0||targetTouches.length>2)
          return;
        //单手指触碰，旋转物体
        if(targetTouches.length==1){
          //获取当前的触碰的位置x/y坐标
          touch1PositionX = targetTouches[0].pageX;
          touch1PositionY = targetTouches[0].pageY;
          //获取当前的围绕x轴y轴的角度
          model1Rotation = mesh1.rotation;
          model2Rotation = mesh2.rotation;
        }
        //两个手指触碰，缩放物体
        else{
          //获取当前的触碰的位置x/y坐标
          touch1PositionX = targetTouches[0].pageX;
          touch1PositionY = targetTouches[0].pageY;
          touch2PositionX = targetTouches[1].pageX;
          touch2PositionY = targetTouches[1].pageY;
          //获取当前的两个触碰点之间的距离,以及当前的缩放比例
          model1Scale = mesh1.scale.x;
          touchDistance = Math.sqrt(Math.pow(touch2PositionX - touch1PositionX,2) + Math.pow(touch2PositionY - touch1PositionY,2));
        }
      };

      //移动拖动手指
      var touchmove = function(event){
        event.preventDefault();
        //如果物体在运动中，则touchmove事件不作任何事情。
        if(!touchDown)
          return;
        var targetTouches = event.targetTouches;
        //排除无接触与三只手指以上接触的。
        if(targetTouches === null || targetTouches.length<=0 || targetTouches.length>2)
          return;
        //单手指触碰，旋转物体
        if(targetTouches.length==1){
          //计算画布的宽和高
          var canvasWidth = targetTouches[0].target.width;
          var canvasHeight = targetTouches[0].target.height;
          //计算每次移动在x轴，y轴的角度差
          var deltaAngleX = (targetTouches[0].pageY - touch1PositionY)/canvasHeight * Math.PI;
          var deltaAngleY = (targetTouches[0].pageX - touch1PositionX)/canvasWidth * Math.PI;
          //转动物体
          rotateModels(mesh1, model1Rotation, deltaAngleX, deltaAngleY, 0.5);
          //rotateModels(mesh2, model2Rotation, deltaAngleX, deltaAngleY, 0.5);
          //重置触碰位置X/Y坐标，以备计算下次角度差
          touch1PositionX = targetTouches[0].pageX;
          touch1PositionY = targetTouches[0].pageY;
          model1Rotation = mesh1.rotation;
          model2Rotation = mesh2.rotation;
        }
        //两个手指触碰，缩放物体
        else{
          //计算当前两个触碰点间的距离与缩放比
          var currentDistance = Math.sqrt(Math.pow(targetTouches[0].pageX - targetTouches[1].pageX,2) + Math.pow(targetTouches[0].pageY - targetTouches[1].pageY,2));
          var currentScale = currentDistance/touchDistance*model1Scale;
          //缩放物体
          scaleModels(mesh1,currentScale);
          //scaleModel2(mesh2,currentScale);
          //重置触碰点之间的距离与缩放比，以备下次计算
          touchDistance = currentDistance;
          model1Scale = currentScale;
          touch1PositionX = targetTouches[0].pageX;
          touch1PositionY = targetTouches[0].pageY;
        }

      };

      //完成触碰，手指离开
      var touchend = function(event){

        event.preventDefault();
        var targetTouches = event.changedTouches;
        //排除无接触与三只手指以上接触的。
        if(targetTouches === null || targetTouches.length<=0 || targetTouches.length>2)
          return;

        //恢复touchDown = false
        timeout = setTimeout(function () {
          touchDown = false;
        }, 3000);

      }

      renderer.domElement.addEventListener("touchstart",touchstart);
      renderer.domElement.addEventListener("touchmove",touchmove);
      renderer.domElement.addEventListener("touchend",touchend);
    </script>
  </body>
</html>
