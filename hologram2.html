<!DOCTYPE html>
<html>
  <head>
    <title>Hologram</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link rel="stylesheet" href="css/main.css"/>
  </head>
  <body ontouchmove="event.preventDefault();">
    <script src="js/three.min.js"></script>
    <script src="js/framerate.js"></script>
    <script src="js/inflate.min.js"></script>
    <script src="js/FBXLoader.js"></script>
    <script>
      //定义画布的宽高
      var width = 0;
      var height = 0;
      if(window.innerHeight<=window.innerWidth){
        width = window.innerHeight/3;
      }else{
        width = window.innerWidth/3;
      }
      height = width;
      //初始化四个场景
      var scene1 = new THREE.Scene();    //前方
      var scene2 = new THREE.Scene();    //右方
      var scene3 = new THREE.Scene();    //后方
      var scene4 = new THREE.Scene();    //左方
      //初始化一台主摄像机
      var camera = new THREE.PerspectiveCamera(75,width/height,0.1,1000);
      //设置摄像机位置
      var cameraZ=290;
      camera.position.set(0,0,cameraZ);
      //设置摄像机镜头目标坐标
      camera.lookAt(0,0,0);
      //初始化四个渲染器
      var renderer1 = new THREE.WebGLRenderer();
      var renderer2 = new THREE.WebGLRenderer();
      var renderer3 = new THREE.WebGLRenderer();
      var renderer4 = new THREE.WebGLRenderer();

      //渲染器设置宽高,与绝对位置
      renderer1.setSize(width,height);
      renderer1.domElement.style.position="absolute";
      renderer2.setSize(width,height);
      renderer2.domElement.style.position="absolute";
      renderer3.setSize(width,height);
      renderer3.domElement.style.position="absolute";
      renderer4.setSize(width,height);
      renderer4.domElement.style.position="absolute";
      //根据window.innerWidth和window.innerHeight计算画布位置
      if(window.innerWidth>=window.innerHeight){
        renderer1.domElement.style.top=height*2+"px";
        renderer1.domElement.style.left=((window.innerWidth-window.innerHeight)/2+width)+"px";
        renderer2.domElement.style.top = height+"px";
        renderer2.domElement.style.left=(window.innerWidth-window.innerHeight)/2+"px";
        renderer3.domElement.style.top = "0px";
        renderer3.domElement.style.left=((window.innerWidth-window.innerHeight)/2+width)+"px";
        renderer4.domElement.style.top = height+"px";
        renderer4.domElement.style.left=((window.innerWidth-window.innerHeight)/2+2*width)+"px";
      }else{
        renderer1.domElement.style.top=((window.innerHeight-window.innerWidth)/2+height*2)+"px";
        renderer1.domElement.style.left=width+"px";
        renderer2.domElement.style.top =((window.innerHeight-window.innerWidth)/2+height)+"px";
        renderer2.domElement.style.left="0px";
        renderer3.domElement.style.top = (window.innerHeight-window.innerWidth)/2+"px";
        renderer3.domElement.style.left=width+"px";
        renderer4.domElement.style.top = ((window.innerHeight-window.innerWidth)/2+height)+"px";
        renderer4.domElement.style.left=(2*width)+"px";
      }

      //将渲染目标与相应div绑定
      document.body.appendChild(renderer1.domElement);
      document.body.appendChild(renderer2.domElement);
      document.body.appendChild(renderer3.domElement);
      document.body.appendChild(renderer4.domElement);

      //定义光照
      var ambientLight = new THREE.AmbientLight(0xffffff,0.5);
      scene1.add(ambientLight.clone());
      scene2.add(ambientLight.clone());
      scene3.add(ambientLight.clone());
      scene4.add(ambientLight.clone());

      var lightBox = new THREE.Object3D();
      var pivot1 = new THREE.Object3D();
      var pivot2 = new THREE.Object3D();
      pivot1.rotation.y = -3*Math.PI/4;
      pivot2.rotation.y = Math.PI/4;
      lightBox.add(pivot1);
      lightBox.add(pivot2)
      //sun light
      var directionLight1 = new THREE.DirectionalLight(0x97adbd,0.8);
      directionLight1.position.set(500,0,0);
      directionLight1.castShadow = true;
      directionLight1.mapSize = new THREE.Vector2(1024,1024);
      pivot1.add(directionLight1);
      //moon light
      var directionLight2 = new THREE.DirectionalLight(0x59888C,0.3);
      directionLight2.position.set(500,0,0);
      directionLight2.castShadow = true;
      directionLight2.mapSize = new THREE.Vector2(1024,1024);
      pivot2.add(directionLight2);
      var lightBox1 = lightBox.clone();
      var lightBox2 = lightBox.clone();
      var lightBox3 = lightBox.clone();
      var lightBox4 = lightBox.clone();
      scene1.add(lightBox1);
      scene2.add(lightBox2);
      scene3.add(lightBox3);
      scene4.add(lightBox4);

      var meshRotation=[],meshScale=[];
      //载入fbx物体
      var mesh,mesh1,mesh2,mesh3,mesh4;
      var fgxloader = new THREE.FBXLoader().
      load("asset/source/lowpoly002.fbx",function(object){
        mesh = object;
        mesh1=mesh.clone().rotateZ(Math.PI);
        mesh2=mesh.clone().rotateZ(Math.PI);
        mesh3=mesh.clone().rotateZ(Math.PI);
        mesh4=mesh.clone().rotateZ(Math.PI);
        mesh1.receiveShadow = true;
        mesh2.receiveShadow = true;
        mesh3.receiveShadow = true;
        mesh4.receiveShadow = true;
        scene1.add(mesh1);
        scene2.add(mesh2);
        scene3.add(mesh3);
        scene4.add(mesh4);
        meshRotation.push(mesh1.rotation);
        meshRotation.push(mesh2.rotation);
        meshRotation.push(mesh3.rotation);
        meshRotation.push(mesh4.rotation);
        meshScale.push(mesh1.scale);
        meshScale.push(mesh2.scale);
        meshScale.push(mesh3.scale);
        meshScale.push(mesh4.scale);
      },function(xhr){
        //console.log("object "+(xhr.loaded/xhr.total*100)+"% loaded");
      },function(error){
        console.log(error);
        alert(error);
      });

      var ModelRotate = function(mesh,resetRotateSpeed,modelRotateSpeed){
        if(mesh===undefined)
          return;
        //保持物体的自转是仅仅围绕Y轴。
        if(mesh.rotation.x > 0){
          mesh.rotation.x -= Math.abs(resetRotateSpeed);
          if(mesh.rotation.x < 0)
            mesh.rotation.x = 0;
            mesh.rotation.y += modelRotateSpeed;
        }
        else if(mesh.rotation.x < 0){
          mesh.rotation.x += Math.abs(resetRotateSpeed);
          if(mesh.rotation.x > 0)
            mesh.rotation.x = 0;
            mesh.rotation.y += modelRotateSpeed;
        }else{
          mesh.rotation.y += modelRotateSpeed;
        }
      };

      var ModelScale = function(mesh,resetScaleSpeed){
        if(mesh===undefined)
          return;
        if(mesh.scale.x > 1){
          mesh.scale.x -= resetScaleSpeed;
          mesh.scale.y -= resetScaleSpeed;
          mesh.scale.z -= resetScaleSpeed;
          if(mesh.scale.x <= 1){
            mesh.scale.x = 1;
            mesh.scale.y = 1;
            mesh.scale.z = 1;
          }
        }
        else if (mesh.scale.x < 1){
          mesh.scale.x += resetScaleSpeed;
          mesh.scale.y += resetScaleSpeed;
          mesh.scale.z += resetScaleSpeed;
          if(mesh.scale.x >= 1){
            mesh.scale.x = 1;
            mesh.scale.y = 1;
            mesh.scale.z = 1;
          }
        }
      };

      var planetRotateSpeed = -0.007,        //行星转速
          resetRotateSpeed = 0.01;          //轨道恢复速度
          resetScaleSpeed = 0.01;           //大小恢复速度
      var update = function(){
        //转动并缩放行星
        ModelRotate(mesh1,resetRotateSpeed,planetRotateSpeed);
        ModelRotate(mesh2,resetRotateSpeed,planetRotateSpeed);
        ModelRotate(mesh3,resetRotateSpeed,planetRotateSpeed);
        ModelRotate(mesh4,resetRotateSpeed,planetRotateSpeed);
        ModelScale(mesh1,resetScaleSpeed);
        ModelScale(mesh2,resetScaleSpeed);
        ModelScale(mesh3,resetScaleSpeed);
        ModelScale(mesh4,resetScaleSpeed);

      };
      //定义渲染函数，
      var render = function(){
        renderer1.render(scene1,camera.clone());
        renderer2.render(scene2,camera.clone().translateX(-cameraZ).translateZ(-cameraZ).rotateY(-Math.PI/2).rotateZ(Math.PI/2));
        renderer3.render(scene3,camera.clone().translateZ(-cameraZ*2).rotateY(Math.PI).rotateZ(Math.PI));
        renderer4.render(scene4,camera.clone().translateX(cameraZ).translateZ(-cameraZ).rotateY(Math.PI/2).rotateZ(-Math.PI/2));
      };
      //定义循环执行函数
      var GameLoop = function(){
        requestAnimationFrame(GameLoop);
        update();
        render();
      };

      GameLoop();
    </script>
    <script src="js/ModelTouchControls.js?v=1.1"></script>
  </body>
</html>
