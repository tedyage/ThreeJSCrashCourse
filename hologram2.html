<!DOCTYPE html>
<html>
<head>
	<title>Hologram</title>
	<meta charset="utf-8">
	<meta name = 'viewport' content = 'width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no'>
	<style type="text/css">
		body{
			margin:0;
			overflow:hidden;
			background:#000;
		}
		canvas{
			width:100%;
			height:100%;
		}
	</style>
	<script type='text/javascript' src="js/three.min.js"></script>
	<script type="text/javascript" src="js/FBXLoader.js"></script>
	<script type="text/javascript" src="js/inflate.min.js"></script>
</head>
<body>
	<div id='container'></div>
	<script type="text/javascript">
		//定义场景
		var scene = new THREE.Scene();
		//定义总体播放区域的宽度
		var play_area_width = innerWidth>=innerHeight?innerHeight:innerWidth;
		//定义View类
		var View = function(){
			this.left = 0;
			this.top = 0;			
			this.getViewSize = function(){
				return ((1.0/3.0)*play_area_width).toFixed(2);
			};
			this.size = this.getViewSize();
		}
		//定义front_view
		var front_view = new View();
		front_view.left = ((1.0/3.0)*play_area_width).toFixed(2);
		front_view.top = ((2.0/3.0)*play_area_width).toFixed(2);
		//定义left_view
		var left_view = new View();
		left_view.left = 0;
		left_view.top = ((1.0/3.0)*play_area_width).toFixed(2);
		//定义top_view
		var back_view = new View();
		back_view.left = ((1.0/3.0)*play_area_width).toFixed(2);
		back_view.top = 0;
		//定义right_view
		var right_view = new View();
		right_view.left = ((2.0/3.0)*play_area_width).toFixed(2);
		right_view.top = ((1.0/3.0)*play_area_width).toFixed(2);
		//定义视窗数组
		var views = [front_view,left_view,back_view,right_view];

		//摄像机设置类
		var Camera = function(){
			this.distance = 250        //摄像机与物体之间的距离
			this.eye = [0,0,0]         //摄像机放置坐标
			this.up = [0,1,0]          //摄像机顶部矢量坐标
			this.angle = 75            //摄像机广角
			this.ratio = 1             //摄像机镜头宽高比
			this.nearest = 0.1         //摄像机拍摄最近距离
			this.farest = 1000         //摄像机拍摄最远距离
			this.camera = new THREE.PerspectiveCamera(this.angle,this.ratio,this.nearest,this.farest)
		};
		//定义front_camera
		var front_camera = new Camera();
		front_camera.eye = [0,0,front_camera.distance];
		front_camera.camera.position.fromArray(front_camera.eye);
		front_camera.camera.lookAt(scene.position);
		//定义left_camera
		var left_camera = new Camera();
		left_camera.eye = [-1*left_camera.distance,0,0];
		left_camera.camera.position.fromArray(left_camera.eye);
		left_camera.camera.lookAt(scene.position);
		left_camera.camera.rotateZ(Math.PI/2);
		//定义back_camera
		var back_camera = new Camera();
		back_camera.eye = [0,0,-1*back_camera.distance];
		back_camera.up = [0,-1,0];
		back_camera.camera.position.fromArray(back_camera.eye);
		back_camera.camera.lookAt(scene.position);
		back_camera.camera.rotateZ(Math.PI);
		//定义right_camera_setting
		var right_camera = new Camera();
		right_camera.eye = [right_camera.distance,0,0];
		right_camera.camera.position.fromArray(right_camera.eye);
		right_camera.camera.lookAt(scene.position);
		right_camera.camera.rotateZ(-Math.PI/2)
		//定义摄像机信息数组
		var cameras = [front_camera,left_camera,back_camera,right_camera];

		//定义环境光照
		var ambientLight = new THREE.AmbientLight(0x909090);
		scene.add(ambientLight);
		//定义平行光
		var directionalLight = new THREE.DirectionalLight(0xffffff,1);
		directionalLight.castShadow = true;
		scene.add(directionalLight);

		//定义模型
		var fbx_file_arr=["asset/source/threejs_mars.fbx","asset/source/threejs_marscloud.fbx"];
		var mesh = new Array();
		var loader = new THREE.FBXLoader();
		var load_fbx = function(){
			//获取载入的球体的最大半径
			fbx_file_arr.forEach(function(fbx){
				loader.load(fbx,function(obj){
					//物体可以接收投影
					obj.children[0].receiveShadow = true;
					mesh.push(obj);
					scene.add(obj);
				},function(xhr){
					console.log(Math.round((xhr.loaded/xhr.total))*100+"%");
				},function(error){
					console.log(error);
				})
			})
		}
		load_fbx();

		//定义渲染器
		var renderer = null;
		var initRenderer = function(width,height){
			renderer = new THREE.WebGLRenderer({antialias:true});
			renderer.setSize(width,height);
			document.getElementById("container").appendChild(renderer.domElement);
		}
		initRenderer(innerWidth,innerHeight);

		//每一帧的修改
		var update = function(){

			mesh.forEach(function(obj){
				obj.rotateY(0.005);
			})
		}
		//设置viewport
		var setViewport = function(view){
			var left = (innerWidth>=innerHeight)?((innerWidth-innerHeight)/2)+parseFloat(view.left):parseFloat(view.left);
			var top = (innerHeight>=innerWidth)?((innerHeight-innerWidth)/2)+parseFloat(view.top):parseFloat(view.top);
			var width = view.size;
			var height = width;
			renderer.setViewport( left, top, width, height );
			renderer.setScissor( left, top, width, height );
			renderer.setScissorTest( true );
			renderer.setClearColor(new THREE.Color(0.0,0.0,0.0));
		}
		//渲染每一帧
		var render = function(){
			//循环每一个view
			for(var i = 0; i < 4; i++){
				var view = views[i];
				setViewport(view);
				renderer.render(scene,cameras[i].camera);
			}
		}

		//定义循环播放
		var GameLoop = function(){
			requestAnimationFrame(GameLoop);
			update();
			render();
		};
		GameLoop();
	</script>	
</body>
</html>