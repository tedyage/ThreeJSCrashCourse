<!DOCTYPE html>
<html>
  <head>
    <title>threejs-hologram</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link rel="stylesheet" href="css/main.css"/>
  </head>
  <body  ontouchmove="event.preventDefault();">
    <div class="container">
      <div class="top"></div>
      <div class="left"></div>
      <div class="right"></div>
      <div class="bottom"></div>
    </div>
    <script src="js/three.min.js"></script>
    <script src="js/framerate.js"></script>
    <script src="js/inflate.min.js"></script>
    <script src="js/FBXLoader.js"></script>
    <script>
      //获取定影样式类名的元素的宽度
      var getWidth = function(className){
        var element = document.getElementsByClassName(className);
        if(!element||element.length<=0)
          return 0;
        else
          return parseFloat(element[0].offsetWidth);
      };
      //获取定影样式类名的元素的高度
      var getHeight = function(className){
        var element = document.getElementsByClassName(className);
        if(!element||element.length<=0)
          return 0;
        else
          return parseFloat(element[0].offsetHeight);
      };

      //设置top/left/right/bottom的高度与绝对位置。
      var heightValue = getWidth("top")+"px";
      document.getElementsByClassName("top")[0].style.height=heightValue;
      document.getElementsByClassName("left")[0].style.height=heightValue;
      document.getElementsByClassName("right")[0].style.height=heightValue;
      document.getElementsByClassName("bottom")[0].style.height=heightValue;
      document.getElementsByClassName("right")[0].style.top=heightValue;
      document.getElementsByClassName("left")[0].style.top=heightValue;
      document.getElementsByClassName("bottom")[0].style.top=parseFloat(heightValue) * 2 + 'px';
      document.getElementsByClassName("container")[0].style.height=parseFloat(heightValue) * 3 + 'px';
    </script>
    <script>
      var touchDown = false;
      //初始化四个场景
      var scene1 = new THREE.Scene();    //前方
      var scene2 = new THREE.Scene();    //右方
      var scene3 = new THREE.Scene();    //后方
      var scene4 = new THREE.Scene();    //左方
      //初始化一台摄像机
      var camera = new THREE.PerspectiveCamera(75,window.getWidth('bottom')/window.getHeight('bottom'),0.1,1000);
      //初始化四个渲染器
      var renderer1 = new THREE.WebGLRenderer();     //前方
      var renderer2 = new THREE.WebGLRenderer();     //左方
      var renderer3 = new THREE.WebGLRenderer();     //后方
      var renderer4 = new THREE.WebGLRenderer();     //右方
      //渲染器设置宽高
      renderer1.setSize(window.getWidth('bottom'),window.getHeight('bottom'));
      renderer2.setSize(window.getWidth('left'),window.getHeight('left'));
      renderer3.setSize(window.getWidth('top'),window.getHeight('top'));
      renderer4.setSize(window.getWidth('right'),window.getHeight('right'));
      //将渲染目标与相应div绑定
      document.getElementsByClassName("bottom")[0].appendChild(renderer1.domElement);
      document.getElementsByClassName("left")[0].appendChild(renderer2.domElement);
      document.getElementsByClassName("top")[0].appendChild(renderer3.domElement);
      document.getElementsByClassName("right")[0].appendChild(renderer4.domElement);
      //设置摄像机位置
      var cameraZ=180;
      camera.position.set(0,0,cameraZ);
      //设置摄像机镜头目标坐标
      camera.lookAt(0,0,0);

      var meshRotation=[],cloudRotation=[],lightBoxRotation=[];
      var meshScale=[],cloudScale=[];

      //定义光照
      var ambientLight = new THREE.AmbientLight(0xffffff,0.2);
      scene1.add(ambientLight.clone());
      scene2.add(ambientLight.clone());
      scene3.add(ambientLight.clone());
      scene4.add(ambientLight.clone());

      var lightBox = new THREE.Object3D();
      var pivot1 = new THREE.Object3D();
      var pivot2 = new THREE.Object3D();
      pivot1.rotation.y = -Math.PI/2;
      pivot2.rotation.y = Math.PI/2;
      lightBox.add(pivot1);
      lightBox.add(pivot2)
      //sun light
      var directionLight1 = new THREE.DirectionalLight(0xffffff,0.8);
      directionLight1.position.set(500,0,0);
      directionLight1.castShadow = true;
      directionLight1.mapSize = new THREE.Vector2(1024,1024);
      pivot1.add(directionLight1);
      //moon light
      var directionLight2 = new THREE.DirectionalLight(0x59888C,0.3);
      directionLight2.position.set(500,0,0);
      directionLight2.castShadow = true;
      directionLight2.mapSize = new THREE.Vector2(1024,1024);
      pivot2.add(directionLight2);
      var lightBox1 = lightBox.clone();
      var lightBox2 = lightBox.clone();
      var lightBox3 = lightBox.clone();
      var lightBox4 = lightBox.clone();
      scene1.add(lightBox1);
      scene2.add(lightBox2);
      scene3.add(lightBox3);
      scene4.add(lightBox4);
      lightBoxRotation.push(lightBox1.rotation);
      lightBoxRotation.push(lightBox2.rotation);
      lightBoxRotation.push(lightBox3.rotation);
      lightBoxRotation.push(lightBox4.rotation);

      //载入fbx物体
      var mesh,mesh1,mesh2,mesh3,mesh4;
      var fgxloader = new THREE.FBXLoader().
      load("asset/source/threejs_mars.fbx",function(object){
        mesh = object;
        mesh1=mesh.clone().rotateZ(Math.PI);
        mesh2=mesh.clone().rotateZ(Math.PI);
        mesh3=mesh.clone().rotateZ(Math.PI);
        mesh4=mesh.clone().rotateZ(Math.PI);
        mesh1.receiveShadow = true;
        mesh2.receiveShadow = true;
        mesh3.receiveShadow = true;
        mesh4.receiveShadow = true;
        scene1.add(mesh1);
        scene2.add(mesh2);
        scene3.add(mesh3);
        scene4.add(mesh4);
        meshRotation.push(mesh1.rotation);
        meshRotation.push(mesh2.rotation);
        meshRotation.push(mesh3.rotation);
        meshRotation.push(mesh4.rotation);
        meshScale.push(mesh1.scale);
        meshScale.push(mesh2.scale);
        meshScale.push(mesh3.scale);
        meshScale.push(mesh4.scale);
      },function(xhr){
        //console.log("object "+(xhr.loaded/xhr.total*100)+"% loaded");
      },function(error){
        alert(error);
      });

      var cloud,cloud1,cloud2,cloud3,cloud4
      fgxloader = new THREE.FBXLoader().
      load("asset/source/threejs_marscloud.fbx",function(object){
        cloud = object;
        cloud1=cloud.clone().rotateZ(Math.PI);
        cloud2=cloud.clone().rotateZ(Math.PI);
        cloud3=cloud.clone().rotateZ(Math.PI);
        cloud4=cloud.clone().rotateZ(Math.PI);
        cloud1.receiveShadow = true;
        cloud2.receiveShadow = true;
        cloud3.receiveShadow = true;
        cloud4.receiveShadow = true;
        scene1.add(cloud1);
        scene2.add(cloud2);
        scene3.add(cloud3);
        scene4.add(cloud4);
        cloudRotation.push(cloud1.rotation);
        cloudRotation.push(cloud2.rotation);
        cloudRotation.push(cloud3.rotation);
        cloudRotation.push(cloud4.rotation);
        cloudScale.push(cloud1.scale);
        cloudScale.push(cloud2.scale);
        cloudScale.push(cloud3.scale);
        cloudScale.push(cloud4.scale);
      },function(xhr){
        //console.log("object "+(xhr.loaded/xhr.total*100)+"% loaded");
      },function(error){
        alert(error);
      });

      var ModelRotate = function(mesh,resetRotateSpeed,modelRotateSpeed){
        if(mesh===undefined)
          return;
        //保持物体的自转是仅仅围绕Y轴。
        if(mesh.rotation.x > 0){
          mesh.rotation.x -= Math.abs(resetRotateSpeed);
          if(mesh.rotation.x < 0)
            mesh.rotation.x = 0;
            mesh.rotation.y += modelRotateSpeed;
        }
        else if(mesh.rotation.x < 0){
          mesh.rotation.x += Math.abs(resetRotateSpeed);
          if(mesh.rotation.x > 0)
            mesh.rotation.x = 0;
            mesh.rotation.y += modelRotateSpeed;
        }else{
          mesh.rotation.y += modelRotateSpeed;
        }
      };

      var ModelScale = function(mesh,resetScaleSpeed){
        if(mesh===undefined)
          return;
        if(mesh.scale.x > 1){
          mesh.scale.x -= resetScaleSpeed;
          mesh.scale.y -= resetScaleSpeed;
          mesh.scale.z -= resetScaleSpeed;
          if(mesh.scale.x <= 1){
            mesh.scale.x = 1;
            mesh.scale.y = 1;
            mesh.scale.z = 1;
          }
        }
        else if (mesh.scale.x < 1){
          mesh.scale.x += resetScaleSpeed;
          mesh.scale.y += resetScaleSpeed;
          mesh.scale.z += resetScaleSpeed;
          if(mesh.scale.x >= 1){
            mesh.scale.x = 1;
            mesh.scale.y = 1;
            mesh.scale.z = 1;
          }
        }
      };

      //定义修改函数，用于修改场景参数
      var lightRotateSpeed = 0.002,          //光源转速
          cloudRotateSpeed = -0.009,         //云层转速
          planetRotateSpeed = -0.007,        //行星转速
          resetRotateSpeed = 0.01;          //轨道恢复速度
          resetScaleSpeed = 0.01;           //大小恢复速度
      var update = function(){
        if(touchDown)
          return;
        //转动光源
        ModelRotate(lightBox1,resetRotateSpeed,-lightRotateSpeed);
        ModelRotate(lightBox2,resetRotateSpeed,-lightRotateSpeed);
        ModelRotate(lightBox3,resetRotateSpeed,-lightRotateSpeed);
        ModelRotate(lightBox4,resetRotateSpeed,-lightRotateSpeed);
        //转动并缩放行星
        ModelRotate(mesh1,resetRotateSpeed,planetRotateSpeed);
        ModelRotate(mesh2,resetRotateSpeed,planetRotateSpeed);
        ModelRotate(mesh3,resetRotateSpeed,planetRotateSpeed);
        ModelRotate(mesh4,resetRotateSpeed,planetRotateSpeed);
        ModelScale(mesh1,resetScaleSpeed);
        ModelScale(mesh2,resetScaleSpeed);
        ModelScale(mesh3,resetScaleSpeed);
        ModelScale(mesh4,resetScaleSpeed);
        //转动并缩放云层
        ModelRotate(cloud1,resetRotateSpeed,cloudRotateSpeed);
        ModelRotate(cloud2,resetRotateSpeed,cloudRotateSpeed);
        ModelRotate(cloud3,resetRotateSpeed,cloudRotateSpeed);
        ModelRotate(cloud4,resetRotateSpeed,cloudRotateSpeed);
        ModelScale(cloud1,resetScaleSpeed);
        ModelScale(cloud2,resetScaleSpeed);
        ModelScale(cloud3,resetScaleSpeed);
        ModelScale(cloud4,resetScaleSpeed);
      };

      //定义渲染函数，
      var render = function(){
        renderer1.render(scene1,camera.clone());
        renderer2.render(scene2,camera.clone().translateX(-cameraZ).translateZ(-cameraZ).rotateY(-Math.PI/2).rotateZ(Math.PI/2));
        renderer3.render(scene3,camera.clone().translateZ(-cameraZ*2).rotateY(Math.PI).rotateZ(Math.PI));
        renderer4.render(scene4,camera.clone().translateX(cameraZ).translateZ(-cameraZ).rotateY(Math.PI/2).rotateZ(-Math.PI/2));
      };
      //定义循环执行函数
      var GameLoop = function(){
        requestAnimationFrame(GameLoop);
        update();
        render();
      };

      GameLoop();
    </script>
    <script src="js/ModelTouchControls.js?v=1.1"></script>
  </body>
</html>
